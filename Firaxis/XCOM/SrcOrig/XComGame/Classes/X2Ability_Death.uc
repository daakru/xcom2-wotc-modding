//---------------------------------------------------------------------------------------
//  Copyright (c) 2016 Firaxis Games, Inc. All rights reserved.
//---------------------------------------------------------------------------------------
class X2Ability_Death extends X2Ability
	config(GameData_SoldierSkills);

var config float DEATH_EXPLOSION_RADIUS_METERS;
var config int DEATH_EXPLOSION_ENV_DMG;

static function array<X2DataTemplate> CreateTemplates()
{
	local array<X2DataTemplate> Templates;

	Templates.AddItem(CreateDeathExplosionAbility());

	return Templates;
}

static function X2AbilityTemplate CreateDeathExplosionAbility()
{
	local X2AbilityTemplate Template;
	local X2AbilityTrigger_EventListener EventListener;
	local X2AbilityMultiTarget_Radius MultiTarget;
	local X2Condition_UnitProperty UnitPropertyCondition;
	local X2Effect_ApplyWeaponDamage DamageEffect;
	local X2Effect_KillUnit KillUnitEffect;

	`CREATE_X2ABILITY_TEMPLATE(Template, 'DeathExplosion');
	Template.IconImage = "img:///UILibrary_PerkIcons.UIPerk_deathexplosion";

	Template.bDontDisplayInAbilitySummary = true;
	Template.AbilitySourceName = 'eAbilitySource_Standard';
	Template.eAbilityIconBehaviorHUD = EAbilityIconBehavior_NeverShow;
	Template.Hostility = eHostility_Offensive;

	// This ability is only valid if there has not been another death explosion on the unit
	UnitPropertyCondition = new class'X2Condition_UnitProperty';
	UnitPropertyCondition.ExcludeDead = false;
	UnitPropertyCondition.ExcludeDeadFromSpecialDeath = true;
	Template.AbilityShooterConditions.AddItem(UnitPropertyCondition);

	EventListener = new class'X2AbilityTrigger_EventListener';
	EventListener.ListenerData.Deferral = ELD_OnStateSubmitted;
	EventListener.ListenerData.EventID = 'UnitDied';
	EventListener.ListenerData.Filter = eFilter_Unit;
	EventListener.ListenerData.EventFn = class'XComGameState_Ability'.static.AbilityTriggerEventListener_Self_VisualizeInGameState;
	Template.AbilityTriggers.AddItem(EventListener);

	EventListener = new class'X2AbilityTrigger_EventListener';
	EventListener.ListenerData.Deferral = ELD_OnStateSubmitted;
	EventListener.ListenerData.EventID = 'UnitUnconscious';
	EventListener.ListenerData.Filter = eFilter_Unit;
	EventListener.ListenerData.EventFn = class'XComGameState_Ability'.static.AbilityTriggerEventListener_Self_VisualizeInGameState;
	Template.AbilityTriggers.AddItem(EventListener);

	// Targets the unit so the blast center is its dead body
	Template.AbilityTargetStyle = default.SelfTarget;
	Template.AbilityToHitCalc = default.DeadEye;

	// Target everything in this blast radius
	MultiTarget = new class'X2AbilityMultiTarget_Radius';
	MultiTarget.fTargetRadius = default.DEATH_EXPLOSION_RADIUS_METERS;
	MultiTarget.bIgnoreBlockingCover = true;
	Template.AbilityMultiTargetStyle = MultiTarget;

	Template.AddTargetEffect(new class'X2Effect_SetSpecialDeath');

	UnitPropertyCondition = new class'X2Condition_UnitProperty';
	UnitPropertyCondition.ExcludeDead = true;
	UnitPropertyCondition.ExcludeFriendlyToSource = false;
	UnitPropertyCondition.ExcludeHostileToSource = false;
	UnitPropertyCondition.FailOnNonUnits = false; //The grenade can affect interactive objects, others
	Template.AbilityMultiTargetConditions.AddItem(UnitPropertyCondition);

	// Everything in the blast radius receives physical damage
	DamageEffect = new class'X2Effect_ApplyWeaponDamage';
	DamageEffect.EffectDamageValue = class'X2Item_DefaultWeapons'.default.DEATH_EXPLOSION_BASEDAMAGE;
	DamageEffect.EnvironmentalDamageAmount = default.DEATH_EXPLOSION_ENV_DMG;
	Template.AddMultiTargetEffect(DamageEffect);

	// If the unit is alive, kill it
	KillUnitEffect = new class'X2Effect_KillUnit';
	KillUnitEffect.BuildPersistentEffect(1, false, false, false, eGameRule_PlayerTurnEnd);
	KillUnitEffect.EffectName = 'KillUnit';
	Template.AddTargetEffect(KillUnitEffect);

	Template.BuildNewGameStateFn = TypicalAbility_BuildGameState;
	Template.BuildVisualizationFn = DeathExplosion_BuildVisualization;
	Template.MergeVisualizationFn = DeathExplostion_MergeVisualization;
	//Template.VisualizationTrackInsertedFn = DeathExplosion_VisualizationTrackInsert;

	Template.FrameAbilityCameraType = eCameraFraming_Never;

	Template.LostSpawnIncreasePerUse = class'X2AbilityTemplateManager'.default.GrenadeLostSpawnIncreasePerUse;
//BEGIN AUTOGENERATED CODE: Template Overrides 'DeathExplosion'
	Template.bFrameEvenWhenUnitIsHidden = true;
//END AUTOGENERATED CODE: Template Overrides 'DeathExplosion'

	return Template;
}

static simulated function DeathExplosion_BuildVisualization(XComGameState VisualizeGameState)
{
	local XComGameStateHistory History;
	local XComGameStateContext_Ability Context;
	local StateObjectReference InteractingUnitRef;
	local VisualizationActionMetadata EmptyTrack;
	local VisualizationActionMetadata BuildTrack;
	local int i, j;
	local X2VisualizerInterface TargetVisualizerInterface;
	local XComGameState_EnvironmentDamage EnvironmentDamageEvent;
	local XComGameState_WorldEffectTileData WorldDataUpdate;
	local XComGameState_InteractiveObject InteractiveObject;
	local X2AbilityTemplate AbilityTemplate;
	local XComGameStateVisualizationMgr VisualizationMgr;
	local X2Action_MarkerNamed JoinAction;
	local array<X2Action> LeafNodes, DamageActions;

	History = `XCOMHISTORY;
	VisualizationMgr = `XCOMVISUALIZATIONMGR;
	Context = XComGameStateContext_Ability(VisualizeGameState.GetContext());

	InteractingUnitRef = Context.InputContext.SourceObject;
	BuildTrack = EmptyTrack;
	BuildTrack.StateObject_OldState = History.GetGameStateForObjectID(InteractingUnitRef.ObjectID, eReturnType_Reference, VisualizeGameState.HistoryIndex - 1);
	BuildTrack.StateObject_NewState = VisualizeGameState.GetGameStateForObjectID(InteractingUnitRef.ObjectID);
	BuildTrack.VisualizeActor = History.GetVisualizer(InteractingUnitRef.ObjectID);

	VisualizationMgr.GetAllLeafNodes(VisualizationMgr.BuildVisTree, LeafNodes);
	JoinAction = X2Action_MarkerNamed(class'X2Action_MarkerNamed'.static.AddToVisualizationTree(BuildTrack, Context, false, , LeafNodes));
	JoinAction.SetName("Join_DeathExplosionStart");

	// Configure the visualization track for the multi targets
	//******************************************************************************************
	for (i = 0; i < Context.InputContext.MultiTargets.Length; ++i)
	{
		InteractingUnitRef = Context.InputContext.MultiTargets[i];
		BuildTrack = EmptyTrack;
		BuildTrack.StateObject_OldState = History.GetGameStateForObjectID(InteractingUnitRef.ObjectID, eReturnType_Reference, VisualizeGameState.HistoryIndex - 1);
		BuildTrack.StateObject_NewState = VisualizeGameState.GetGameStateForObjectID(InteractingUnitRef.ObjectID);
		BuildTrack.VisualizeActor = History.GetVisualizer(InteractingUnitRef.ObjectID);
		BuildTrack.LastActionAdded = JoinAction;

		for (j = 0; j < Context.ResultContext.MultiTargetEffectResults[i].Effects.Length; ++j)
		{
			Context.ResultContext.MultiTargetEffectResults[i].Effects[j].AddX2ActionsForVisualization(VisualizeGameState, BuildTrack, Context.ResultContext.MultiTargetEffectResults[i].ApplyResults[j]);
		}

		TargetVisualizerInterface = X2VisualizerInterface(BuildTrack.VisualizeActor);
		if (TargetVisualizerInterface != none)
		{
			//Allow the visualizer to do any custom processing based on the new game state. For example, units will create a death action when they reach 0 HP.
			TargetVisualizerInterface.BuildAbilityEffectsVisualization(VisualizeGameState, BuildTrack);
		}
	}

	AbilityTemplate = class'XComGameState_Ability'.static.GetMyTemplateManager().FindAbilityTemplate(Context.InputContext.AbilityTemplateName);
	//****************************************************************************************
	//Configure the visualization tracks for the environment
	//****************************************************************************************
	foreach VisualizeGameState.IterateByClassType(class'XComGameState_EnvironmentDamage', EnvironmentDamageEvent)
	{
		BuildTrack = EmptyTrack;
		BuildTrack.VisualizeActor = none;
		BuildTrack.StateObject_NewState = EnvironmentDamageEvent;
		BuildTrack.StateObject_OldState = EnvironmentDamageEvent;
		BuildTrack.LastActionAdded = JoinAction;

		for (i = 0; i < AbilityTemplate.AbilityMultiTargetEffects.Length; ++i)
		{
			AbilityTemplate.AbilityMultiTargetEffects[i].AddX2ActionsForVisualization(VisualizeGameState, BuildTrack, 'AA_Success');
		}
	}

	foreach VisualizeGameState.IterateByClassType(class'XComGameState_WorldEffectTileData', WorldDataUpdate)
	{
		BuildTrack = EmptyTrack;
		BuildTrack.VisualizeActor = none;
		BuildTrack.StateObject_NewState = WorldDataUpdate;
		BuildTrack.StateObject_OldState = WorldDataUpdate;
		BuildTrack.LastActionAdded = JoinAction;

		for (i = 0; i < AbilityTemplate.AbilityMultiTargetEffects.Length; ++i)
		{
			AbilityTemplate.AbilityMultiTargetEffects[i].AddX2ActionsForVisualization(VisualizeGameState, BuildTrack, 'AA_Success');
		}
	}
	//****************************************************************************************

	//Process any interactions with interactive objects
	foreach VisualizeGameState.IterateByClassType(class'XComGameState_InteractiveObject', InteractiveObject)
	{
		// Add any doors that need to listen for notification
		if (InteractiveObject.IsDoor() && InteractiveObject.HasDestroyAnim() && InteractiveObject.InteractionCount % 2 != 0) //Is this a closed door?
		{
			BuildTrack = EmptyTrack;
			//Don't necessarily have a previous state, so just use the one we know about
			BuildTrack.StateObject_OldState = InteractiveObject;
			BuildTrack.StateObject_NewState = InteractiveObject;
			BuildTrack.VisualizeActor = History.GetVisualizer(InteractiveObject.ObjectID);
			BuildTrack.LastActionAdded = JoinAction;

			class'X2Action_BreakInteractActor'.static.AddToVisualizationTree(BuildTrack, Context);
		}
	}

	VisualizationMgr.GetNodesOfType(VisualizationMgr.BuildVisTree, class'X2Action_ApplyWeaponDamageToUnit', DamageActions);
	for( i = 0; i < DamageActions.Length; ++i )
	{
		VisualizationMgr.DisconnectAction(DamageActions[i]);
		VisualizationMgr.ConnectAction(DamageActions[i], VisualizationMgr.BuildVisTree, false, JoinAction);
	}

	DamageActions.Length = 0;
	VisualizationMgr.GetNodesOfType(VisualizationMgr.BuildVisTree, class'X2Action_ApplyWeaponDamageToTerrain', DamageActions);
	for (i = 0; i < DamageActions.Length; ++i)
	{
		VisualizationMgr.DisconnectAction(DamageActions[i]);
		VisualizationMgr.ConnectAction(DamageActions[i], VisualizationMgr.BuildVisTree, false, JoinAction);
	}

	DamageActions.Length = 0;
	VisualizationMgr.GetNodesOfType(VisualizationMgr.BuildVisTree, class'X2Action_BreakInteractActor', DamageActions);
	for (i = 0; i < DamageActions.Length; ++i)
	{
		VisualizationMgr.DisconnectAction(DamageActions[i]);
		VisualizationMgr.ConnectAction(DamageActions[i], VisualizationMgr.BuildVisTree, false, JoinAction);
	}
}

function DeathExplostion_MergeVisualization(X2Action BuildTree, out X2Action VisualizationTree)
{
	local XComGameStateVisualizationMgr VisMgr;
	local XComGameStateContext_Ability Context;
	local X2Action_ExplodingUnitDeathAction DeathAction;
	local X2Action BuildTreeStartNode, BuildTreeEndNode;

	VisMgr = `XCOMVISUALIZATIONMGR;

	Context = XComGameStateContext_Ability(BuildTree.StateChangeContext);

	if( Context != none )
	{
		DeathAction = X2Action_ExplodingUnitDeathAction(VisMgr.GetNodeOfType(VisualizationTree, class'X2Action_ExplodingUnitDeathAction', , Context.InputContext.SourceObject.ObjectID));

		if( DeathAction != none )
		{
			BuildTreeStartNode = VisMgr.GetNodeOfType(BuildTree, class'X2Action_MarkerTreeInsertBegin');
			BuildTreeEndNode = VisMgr.GetNodeOfType(BuildTree, class'X2Action_MarkerTreeInsertEnd');

			BuildTreeStartNode.AddInputEvent('Visualizer_AbilityHit');

			VisMgr.InsertSubtree(BuildTreeStartNode, BuildTreeEndNode, DeathAction);
		}
	}
}
static function DeathExplosion_VisualizationTrackInsert(XComGameStateContext_Ability Context, int OuterIndex, int InnerIndex)
{
	/*
	local int TrackIndex, MoveToIndex, MoveFromIndex;
	local X2Action_EnterCover EnterCoverAction;
	local XGUnit OuterIndexActor;

	OuterIndexActor = XGUnit(VisualizationTracks[OuterIndex].VisualizeActor);

	if (OuterIndexActor != none)
	{
		if (Context.InputContext.MultiTargets.Find('ObjectID', OuterIndexActor.ObjectID) != INDEX_NONE)
		{
			// This TrackActor is in the MultiTargets
			for (TrackIndex = InnerIndex - 1; TrackIndex >= 0; --TrackIndex)
			{
				EnterCoverAction = X2Action_EnterCover(VisualizationTracks[OuterIndex].TrackActions[TrackIndex]);
				if (EnterCoverAction != none)
				{
					// Walk this action backwards so it can finish after taking the damage
					MoveToIndex = TrackIndex;
					MoveFromIndex = MoveToIndex + 1;
					while (MoveFromIndex <= InnerIndex)
					{
						// Group the waits (or other unwanted actions) together so we can remove them at the same time
						if (X2Action_WaitForAbilityEffect(VisualizationTracks[OuterIndex].TrackActions[MoveFromIndex]) == none)
						{
							// This action is not a wait, so swap with move.
							VisualizationTracks[OuterIndex].TrackActions[MoveToIndex] = VisualizationTracks[OuterIndex].TrackActions[MoveFromIndex];

							++MoveToIndex;
						}

						++MoveFromIndex;
					}
					VisualizationTracks[OuterIndex].TrackActions[InnerIndex] = EnterCoverAction;

					if (MoveToIndex != InnerIndex)
					{
						// There are unwanted tracks, remove from MoveToIndex to the index before InnerIndex
						VisualizationTracks[OuterIndex].TrackActions.Remove(MoveToIndex, InnerIndex - MoveToIndex);
					}

					break;
				}
			}
		}
	}
	*/
}

//DefaultProperties
//{
//	SpecialDeathExplosionName="DeathExplosion"
//}
